#include <iostream>
#include <vector>
#include <list>
#include <stack>
using namespace std;

class Graph {
    int V; // Number of vertices
    list<int> *adj; // Adjacency list
    int time; // Timer used in DFS
    
    // A utility function to find biconnected components using DFS
    void BCCUtil(int u, int disc[], int low[], stack<pair<int, int>> &st, int parent[]);
    
public:
    Graph(int V); // Constructor
    void addEdge(int v, int w); // Function to add an edge
    void BCC(); // Function to find biconnected components
};

// Constructor
Graph::Graph(int V) {
    this->V = V;
    adj = new list<int>[V];
    time = 0;
}

// Function to add an edge
void Graph::addEdge(int v, int w) {
    adj[v].push_back(w);
    adj[w].push_back(v); // Since it's an undirected graph
}

// DFS based function to find biconnected components
void Graph::BCCUtil(int u, int disc[], int low[], stack<pair<int, int>> &st, int parent[]) {
    // Initialize discovery time and low value
    disc[u] = low[u] = ++time;
    int children = 0;

    // Go through all vertices adjacent to this
    for (auto v : adj[u]) {
        // If v is not visited
        if (disc[v] == -1) {
            children++;
            parent[v] = u;
            st.push({u, v}); // Store the edge in the stack

            // Recur for DFS
            BCCUtil(v, disc, low, st, parent);

            // Check if the subtree rooted at v has a connection back to an ancestor of u
            low[u] = min(low[u], low[v]);

            // If u is an articulation point, pop all edges till (u, v)
            if ((parent[u] == -1 && children > 1) || (parent[u] != -1 && low[v] >= disc[u])) {
                cout << "Biconnected Component: ";
                while (st.top().first != u || st.top().second != v) {
                    cout << "(" << st.top().first << ", " << st.top().second << ") ";
                    st.pop();
                }
                cout << "(" << st.top().first << ", " << st.top().second << ")\n";
                st.pop();
            }
        }
        // Update low value of u for parent function calls
        else if (v != parent[u]) {
            low[u] = min(low[u], disc[v]);
            if (disc[v] < disc[u]) {
                st.push({u, v});
            }
        }
    }
}

// Function to find and print biconnected components
void Graph::BCC() {
    int *disc = new int[V];
    int *low = new int[V];
    int *parent = new int[V];
    stack<pair<int, int>> st;

    // Initialize parent and visited arrays
    for (int i = 0; i < V; i++) {
        disc[i] = -1;
        low[i] = -1;
        parent[i] = -1;
    }

    // Call the recursive helper function to find biconnected components
    for (int i = 0; i < V; i++) {
        if (disc[i] == -1) {
            BCCUtil(i, disc, low, st, parent);
        }

        // If stack is not empty, pop all the edges to form a biconnected component
        while (!st.empty()) {
            cout << "Biconnected Component: ";
            cout << "(" << st.top().first << ", " << st.top().second << ") ";
            st.pop();
            cout << endl;
        }
    }

    delete[] disc;
    delete[] low;
    delete[] parent;
}

int main() {
    // Create graph with 5 vertices
    Graph g(5);

    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(1, 3);
    g.addEdge(3, 4);

    cout << "Biconnected components in the graph are:\n";
    g.BCC();

    return 0;
}
